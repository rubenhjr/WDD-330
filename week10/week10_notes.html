<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="style.css">
        <title>Week 10 Notes</title>
    </head>
    <body>
        <h2>Validation forms:</h2>
        <ul class="first">
            <li>
                Client-side form validation- it is important to ensure all required form controls are filled out, in the correct format and helps ensure data submitted matches the requirements set forth in the various form controls.
            </li>
            <li>Client-side validation is an initial check and an important feature of good user experience; by catching invalid data on the client-side, the user can fix it straight away. If it gets to the server and is then rejected, a noticeable delay is caused by a round trip to the server and then back to the client-side to tell the user to fix their data.</li>
            <li>Client-side validation should not be considered an exhaustive security measure.</li>
            <li>Form validation- When you enter data, the browser and/or the web server will check to see that the data is in the correct format and within the constraints set by the application. </li>
            <li>Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation.</li>
            <li><b>There are two different types of client-side validation: </b></li>
            <li><b>Built-in form validation</b> uses HTML5 form validation features, which we've discussed in many places throughout this module.</li>
            <li><b>JavaScript validation</b> is coded using JavaScript. This validation is completely customizable, but you need to create it all (or use a library).</li>
            <li>You must use JavaScript if you want to take control over the look and feel of native error messages or to deal with legacy browsers that do not support HTML's built-in form validation.</li>
        </ul>
        <h2>Using Fetch</h2>
        <ul class="second">
            <li>Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses.</li>
            <li>It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.</li>
            <li>Fetch provides a better alternative that can be easily used by other technologies such as Service Workers. Fetch also provides a single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP.</li>
            <li>fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500. Instead, as soon as the server responds with headers, the Promise will resolve normally (with the ok property of the response set to false if the response isn’t in the range 200–299), and it will only reject on network failure or if anything prevented the request from completin</li>
            <li>fetch() won’t send cross-origin cookies unless you set the credentials init option. </li>
            <li>The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings.</li>
            <li>Instead of passing a path to the resource you want to request into the fetch() call, you can create a request object using the Request() constructor, and pass that in as a fetch() method argument.</li>
            <li>The Headers interface allows you to create your own headers object via the Headers() constructor. A headers object is a simple multi-map of names to values.</li>
            <li>As you have seen above, Response instances are returned when fetch() promises are resolved.
            The most common response properties you'll use are: <b>Response.status, Response.statusText, Respose.ok </b></li>
        </ul>
    </body>
</html>