<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="style.css">
        <title>Week08 Notes</title>
    </head>
    <body>
        <h2>Chapter 8: Transforms and Transitions</h2>
        <ul class="ch8">
            <li> The CSS3 transform property lets you lets you translate, rotate, scale, and/or skew any element on the page.</li>
            <li>The value of the transform property is one or more transform functions (separated by spaces) that will be applied in the order they’re provided. </li>
            <li>Translation functions allow you to move elements left, right, up, or down.</li>
            <li>These functions are similar to the behavior of position: relative; when declaring top and left, moving elements up and down or left and right along the x and y axes.</li>
            <li>If you only want to move an element vertically or horizontally, you can use the translatex or translatey</li>
            <li>The scale(x,y) function scales an element by the defined factors horizontally then vertically.</li>
            <li>If only one value is provided, it will be used for both the x and y values, growing or shrinking your element or pseudo-element while maintaining the original aspect ratio.</li>
            <li>As with translate, you can also use the scaleX(x) or scaleY(y) functions. These functions will scale only the horizontal dimensions or only the vertical dimensions respectively.</li>
            <li>A scaled element will grow outwards from or shrink inwards towards its center; in other words, the element’s center will stay in the same place as its dimensions change.</li>
            <li>It’s also worth remembering that scaling, like translation, has no impact on the document flow. This means that if you scale inline-block elements, text around it will fail to accommodate it with reflowing.</li>
            <li>The rotate() function rotates an element around the point of origin by a specified angle value. </li>
            <li> As with scale, by default the point of origin is the element’s center. </li>
            <li>The skew(x,y) function specifies a skew along the x and y axes.</li>
            <li>As you’d expect, the x specifies the skew on the x axis, and the y specifies the skew on the y axis.</li>
            <li>This is done using the transform-origin property. It has the same syntax as the background-position property, and defaults to the center of the object (so that scales and rotations will be around the center of the box by default).</li>
            <li>The order of transform functions does matter: if you rotate before translating, your translate direction will be on the rotated axis.</li>
            <li>You can also scale an element by altering its width and height, or changing the font-size. Remember, though, that while transformed elements still take up the space they did before being scaled, altering a width, height or font-size alters the space allocated for the element and can affect the layout.</li>
            <li>Here are the steps to create a simple transition using only CSS: <br>
                1.Declare the original state of the element in the default style declaration. <br>
                2.Declare the final state of your transitioned element; for example, a :hover state. <br>
                3.Include the transition functions in your default style declaration using the transition properties, including: transition-property, transition-duration, transition-timing-function, and transition-delay. We’ll look at each of these and how they work shortly.</li>
            <li>If using the shorthand property, be careful with your animation-name. You want to avoid accidentally using any animation property key term such as forwards, running, or alternate. Those three key terms in particular have caused many developers hours of debugging. If you include a key term, the browser will assume that the first occurrence of a valid value for any of the longhand properties is the value for that property, not the value for the animation-name property.</li>
        </ul>

        <h2>Chapter 12: Canvas, SVG, and Drag and Drop</h2>
        <ul class="ch12">
            <li>The first step to using canvas is to add a canvas element to the page:</li>
            <li>The text in between the canvas tags will only be shown if the canvas element is not supported by the visitor’s browser.
             Since drawing on the canvas is done using JavaScript, we’ll need a way to grab the element from the DOM.</li>
            <li>why not set the width and height via CSS? It’s because the width and height attributes determine how large the canvas’s coordinate system is. </li>
            <li>All drawing on the canvas happens via the Canvas JavaScript API.</li>
            <li>We can use any CSS color value to set the stroke or fill color, as long as we specify it as a string: a hexadecimal value such as #00FFFF, a color name such as red or blue, or an RGB value such as rgb(0, 0, 255). We can even use the property rgba to set a semitransparent stroke or fill color.</li>
            <li>Instead of a color as our fillStyle, we could have used a CanvasGradient or a CanvasPattern object. Let’s create a pattern on the second canvas element (whose ID is demo2) on the canvas.html page.</li>
            <li>Setting the src attribute will tell the browser to start downloading the image; however, if we try to use it immediately to create our gradient, we might run into some problems, because the image may still be loading (depending on whether it is in the browser cache).</li>
            <li>what is that function statement that comes right before the call to img.onload? It’s an anonymous function. Anonymous functions are much like regular functions except, as you might guess, they are without names. When you see an anonymous function defined as an event listener, it means that the anonymous function is being bound to that event. In other words, the code inside that anonymous function will be run when the load event is fired.</li>
            <li>We can also create a CanvasGradient object to use as our fillStyle. To create a CanvasGradient, we call one of two methods: createLinearGradient() or createRadialGradient(); then we add one or more color stops to the gradient.</li>
            <li>If we create an image programmatically using the Canvas API, but decide we’d like to have a local copy of our drawing, we can use the API’s toDataURL method to save our drawing. toDataURL creates a URL with the image in it, (either a png or jpg, whichever is specified). You can then right-click the image at this URL, and save it as a PNG or JPEG.</li>
            <li>SVG stands for Scalable Vector Graphics, a specific file format that allows you to describe vector graphics using XML.</li>
            <li>Unlike canvas, images created with SVG are available via the DOM. This enables technologies such as screen readers to see what’s present in an SVG object through its DOM node, as well as allowing you to inspect SVG using your browser’s developer tools.</li>
            <li>Canvas allows for pixel manipulation, as we saw when we turned our video from color to black and white. One downside of canvas is that it operates in what’s known as immediate mode. This means that if you ever want to add more to the canvas, you’re unable to simply add to what’s already there.</li>
            <li>By contrast, what you draw to SVG is accessible via the DOM, because its mode is retained mode, meaning that the structure of the image is preserved in the XML document that describes it. SVG also has, at this time, a more complete set of tools to help you work with it, such as the Raphaël library and Inkscape.</li>
            <li>In summary, if you need to paint pixels to the screen and have no concerns about the ability to retrieve and modify your shapes, canvas is probably the better choice. If, on the other hand, you need to be able to access and change specific aspects of your graphics, SVG might be more appropriate.</li>
            <li>the Drag and Drop API. This API allows us to specify that certain elements are draggable, and then specify what should happen when these draggable elements are dragged over or dropped onto other elements on the page.</li>
            <li>There are two major kinds of functionality you can implement with Drag and Drop: dragging files from your computer into a web page—in combination with the File API—or dragging elements into other elements on the same page.</li>
            <li>Note that draggable is not a Boolean attribute, so you have to explicitly set it to true.</li>
            <li>DataTransfer objects are one type of object outlined in the Drag and Drop API. These objects allow us to set and get data about the elements that are being dragged.  Specifically, DataTransfer lets us define two pieces of information:<br>
                *the type of data we’re saving of the draggable element<br>
                *the value of the data itself</li>
            <li>Now our mouse images are set up to be dragged. Yet, when we try to drag them around, we’re unable to drop them anywhere—which is no fun.
            The reason is that by default, elements on the page aren’t set up to receive dragged items. In order to override the default behavior on a specific element, we must stop it from happening. We can do that by creating two more event listeners.
            The two events we need to monitor for are dragover and drop. As you’d expect, dragover fires when you drag an item over an element, and drop fires when you drop an item on it.</li>
        </ul>
    </body>
</html>